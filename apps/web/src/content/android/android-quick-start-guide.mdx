import { Callout } from 'nextra/components';

# Android Quick Start Guide

## Prerequisites

You should already have

- An Android project created in Android Studio. You may create an empty project with the wizard. Leap Android SDK is Kotlin-first. We recommend to work with the SDK only in Kotlin.
- A working Android device supports `arm64-v8a` ABI with the developer mode enabled. Recommend to have 3GB+ RAM to run the models.
- The minimal SDK requirement is API 31. You may declare it in `build.gradle.kts` as

```kotlin
android {
    defaultConfig {
        minSdk = 31
        targetSdk = 35
    }
}
```

<Callout type="warning">
  The SDK may crash on loading model bundles on simulators. A physical Android device is
  recommended.
</Callout>

## Import the LeapSDK

Add following dependencies into `$PROJECT_ROOT/app/build.gradle.kts`:

```kotlin
dependencies {
  ...

  implementation("ai.liquid.leap:leap-sdk:0.1.0")
}
```

Then perform a project sync in Android Studio to fetch the LeapSDK artifacts.

## Download model bundles

Go to [Leap Model Library](https://leap.liquid.ai/models) to find a model that matches your needs.

In order to easily load the model on device, we can need to push the bundle files to the device with following command. Suppose the downloaded model file is located at `~/Downloads/model.bundle`, run the following commands to push the model files to the device:

```shell
$ adb shell mkdir -p /data/local/tmp/leap/
$ adb push ~/Downloads/model.bundle /data/local/tmp/leap/model.bundle
```

## Load Model in Code

`LeapClient.loadModel` suspend function loads a model bundle file and return a model runner instance to run the model. This function takes some time to finish as loading the model is an heavy I/O operation, but it is safe to call on the main thread. The function should be executed in a coroutine scope.

```kotlin
lifecycleScope.launch {
  try {
    modelRunner = LeapClient.loadModel("/data/local/tmp/leap/model.bundle")
   }
   catch (e: LeapModelLoadingException) {
     Log.e(TAG, "Failed to load the model. Error message: ${e.message}")
   }
 }
```

## Generate content with the model

In order to generate contents, a conversation object should be created from the model runner.

```kotlin
val conversation = modelRunner.createConversation()
```

With a user input text, we can use `Conversation.generateResponse` function to invoke the generation. Its return value is a Kotlin asynchronous flow of `MessageResponse`, which can be processed with Kotlin flow operators.

```kotlin
val input = "Here is a user message!"
val generationJob = lifecycleScope.launch {
	conversation.generateResponse(input).onEach {
		when (it) {
	    is MessageResponse.Chunk -> {
		    Log.d(TAG, "text chunk: ${it.text}")
	    }
	    is MessageResponse.ReasoningChunk -> {
		    Log.d(TAG, "reasoning chunk: ${it.text}")
	    }
	    else -> {
		    // ignore other response
	    }
	  }
	}
	.onCompletion {
	   Log.d(TAG, "Generation done!")
	}
	.catch { exception ->
	  Log.e(TAG, "Error in generation: $exception")
	}
	.collect()
}
```

In this code piece:

- `onEach` callback will be called when the model generates a chunk of content.
- `onCompletion` callback will be called when the generation is done. At this time point, `conversation.history` will have the latest message generated by the model.
- `catch` callback will be called when an exception is thrown from the generation.

To interrupt the generation, simply cancel the generation job returned from the coroutine scope `launch` method:

```kotlin
generationJob.cancel()
```

## Examples

See [LeapSDK-Examples](https://github.com/Liquid4All/LeapSDK-Examples) for complete example apps of LeapSDK.
